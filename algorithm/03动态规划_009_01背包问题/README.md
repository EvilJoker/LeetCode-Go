# 动态规划之 0/1 背包问题

## 题目介绍

0/1 背包问题是一个经典的动态规划问题。给定一组物品，每个物品有一个重量和价值，并给定一个背包的容量，要求我们在不超过背包容量的前提下，选择若干物品，使得这些物品的总价值最大。

### 输入

- 物品的数量 `n`
- 背包的容量 `W`
- 每个物品的重量数组 `w[]`，每个物品的价值数组 `v[]`

### 输出

- 背包可以装下的最大价值

## 解题思路

1. **状态定义**：
   定义 `dp[i][j]` 表示前 `i` 个物品中，背包容量为 `j` 时能获得的最大价值。---> 模型很重要

2. **状态转移方程**：
   - 不选择当前物品：`dp[i][j] = dp[i-1][j]`
   - 选择当前物品：`dp[i][j] = dp[i-1][j-w[i]] + v[i]` ---> 很关键 要减去当前的重量

   即：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])`

3. **初始化**：
   - `dp[0][j] = 0`，表示没有物品时，任何容量的背包价值都是0。

4. **最终结果**：
   - `dp[n][W]` 表示考虑所有物品时，背包容量为 `W` 时的最大价值。

## 示例

```golang
package main

import "fmt"

// 0/1背包问题
func knapsack(weights []int, values []int, W int) int {
    n := len(weights)
    // 创建一个一维数组来存储最大值
    dp := make([]int, W+1)

    // 遍历所有物品
    for i := 0; i < n; i++ {
        // 逆序遍历背包容量
        for j := W; j >= weights[i]; j-- {
            dp[j] = max(dp[j], dp[j-weights[i]]+values[i])
        }
    }

    return dp[W]
}

// 求最大值的辅助函数
func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    // 物品的重量和价值
    weights := []int{2, 3, 4, 5}
    values := []int{3, 4, 5, 6}
    W := 5  // 背包容量

    result := knapsack(weights, values, W)
    fmt.Println("最大价值是:", result)  // 输出最大价值
}
```

关键代码注释
dp := make([]int, W+1)：我们只需要使用一维数组 dp 来存储每个背包容量下的最大价值。
for j := W; j >= weights[i]; j--：逆序遍历背包容量，避免重复使用同一物品。
dp[j] = max(dp[j], dp[j-weights[i]]+values[i])：选择当前物品或不选择当前物品，取较大值。

## 特点

时间复杂度：O(n * W)，其中 n 是物品的数量，W 是背包的容量。通过使用一维数组优化空间复杂度。
空间复杂度：O(W)，只需要一个一维数组来存储结果，相比二维数组节省了空间。
贪心 vs 动态规划：0/1背包问题不能使用贪心算法来解决，必须使用动态规划，因为贪心算法在某些情况下不能获得最优解。
