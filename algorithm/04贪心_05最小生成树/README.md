# 贪心之最小生成树

## 题目介绍

最小生成树（MST）是一个连通图的一个子图，包含所有的顶点，并且边的总权重最小。生成树的一个关键特性是它包含所有的顶点，并且没有环，形成一个树形结构。

**输入**：一个无向图，包含顶点和边，每条边都有一个权重。

**输出**：图的一个最小生成树，包含所有顶点，且总权重最小。

## 解题思路

最小生成树问题可以通过贪心算法解决。贪心算法在每一步选择中，总是做出当前看来最好的选择，期望通过一系列的局部最优选择达到全局最优。

常见的最小生成树算法有：

1. **普里姆算法（Prim's Algorithm）**：从一个点开始，逐步扩展生成树，选择每次权重最小的边加入生成树。
2. **克鲁斯卡尔算法（Kruskal's Algorithm）**：通过按权重排序所有边，逐一选择不形成环的边加入生成树。

### 选择普里姆算法进行实现

1. 初始化一个节点集合，选择一个起始节点。
2. 从当前生成树的节点集合出发，选择一条权重最小的边连接到图中还未包含的节点。
3. 重复上述步骤，直到所有节点都被包含在生成树中。

## Golang 示例（普里姆算法）

```golang
package main

import (
    "fmt"
    "math"
)

// 图的边结构体
type Edge struct {
    from, to, weight int
}

// 最小生成树的普里姆算法
func prim(graph [][]int) int {
    n := len(graph) // 图中节点的个数
    visited := make([]bool, n)  // 记录每个节点是否已经加入最小生成树
    minWeight := 0  // 最小生成树的总权重

    // 从第一个节点开始
    visited[0] = true

    for i := 1; i < n; i++ {
    minEdge := Edge{-1, -1, math.MaxInt}  // 初始化一个最大值的边

    // 在已经加入生成树的节点中，选择一条权重最小的边
    for u := 0; u < n; u++ {
        if visited[u] {
        for v := 0; v < n; v++ {
            if !visited[v] && graph[u][v] != 0 && graph[u][v] < minEdge.weight {
            minEdge = Edge{u, v, graph[u][v]}
            }
        }
        }
    }

    // 选择了最小的边，将目标节点加入最小生成树
    visited[minEdge.to] = true
    minWeight += minEdge.weight
    }

    return minWeight
}

func main() {
    // 图的邻接矩阵表示，graph[i][j]表示从i到j的边的权重
    graph := [][]int{
    {0, 2, 0, 6, 0},
    {2, 0, 3, 8, 5},
    {0, 3, 0, 0, 7},
    {6, 8, 0, 0, 9},
    {0, 5, 7, 9, 0},
    }

    // 计算最小生成树的权重
    result := prim(graph)
    fmt.Printf("最小生成树的总权重是: %d\n", result)
}
```

关键注释说明
Edge结构体：用于表示图的边，包含起始节点from、目标节点to、和边的权重weight。
prim函数：实现了普里姆算法，通过选择每次权重最小的边逐步构建最小生成树，直到所有节点都被包括在内。
visited数组：记录每个节点是否已经被包括在最小生成树中。
minEdge：表示当前从已选节点集合到未选节点集合的最小边。

## 特点

贪心算法：每次都选择权重最小的边加入生成树，确保每步的选择是局部最优的。
时间复杂度：O(n^2)，其中n是节点的数量。最坏情况下需要检查每一对节点之间的边。
适用场景：适用于节点数较小且图的边不稀疏的情况。
