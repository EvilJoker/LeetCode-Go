# 定义

矩阵连乘问题是一种经典的动态规划问题。给定一个矩阵链（多个矩阵），我们需要通过选择合适的括号化方式来使矩阵连乘的计算代价最小。  
矩阵乘法的代价由矩阵的行和列大小决定，因此问题的关键是找到最佳的分割点，使得总计算代价最小。

## 解题思路

1. **定义状态**：
   - `dp[i][j]` 表示从第 `i` 个矩阵到第 `j` 个矩阵的最小计算代价。
   - 边界条件：`dp[i][i] = 0`（单个矩阵不需要计算）。

2. **状态转移方程**：
   - 对于每个可能的分割点 `k`，将问题分为两部分：
     - 左部分：`dp[i][k]`（从第 `i` 个矩阵到第 `k` 个矩阵的最小计算代价）。
     - 右部分：`dp[k+1][j]`（从第 `k+1` 个矩阵到第 `j` 个矩阵的最小计算代价）。
     - 加上当前划分的计算代价：`p[i-1] * p[k] * p[j]`。
   - 转移方程：  
     `dp[i][j] = min(dp[i][k] + dp[k+1][j] + p[i-1]*p[k]*p[j])`。

3. **最终结果**：
   - `dp[1][n]` 表示从第一个矩阵到第 `n` 个矩阵的最小计算代价。

4. **实现**：
   - 使用二维数组存储 `dp` 值。
   - 使用嵌套循环计算所有子问题。

## 示例

```golang
package main

import (
 "fmt"
 "math"
)

// 矩阵连乘问题的解决方法
func matrixChainOrder(p []int) int {
 n := len(p) - 1 // 矩阵数量为 len(p) - 1
 // 初始化 dp 表
 dp := make([][]int, n)
 for i := range dp {
  dp[i] = make([]int, n)
 }

 // 遍历所有可能的链长度 l，从 2 开始
 for l := 2; l <= n; l++ {
  for i := 0; i <= n-l; i++ {
   j := i + l - 1
   dp[i][j] = math.MaxInt32
   // 尝试在 i 到 j 之间找到分割点 k
   for k := i; k < j; k++ {
    // 计算当前划分的代价
    cost := dp[i][k] + dp[k+1][j] + p[i]*p[k+1]*p[j+1]
    // 更新最小值
    if cost < dp[i][j] {
     dp[i][j] = cost
    }
   }
  }
 }

 // 返回最终结果
 return dp[0][n-1]
}

func main() {
 // 矩阵的维度数组
 p := []int{40, 20, 30, 10, 30}
 // 计算矩阵连乘的最小代价
 result := matrixChainOrder(p)
 fmt.Printf("最小计算代价是: %d\n", result)
}
```

## 特点

1. **时间复杂度**：  
   动态规划的时间复杂度为 `O(n^3)`，适用于矩阵数量不多的情况。

2. **空间复杂度**：  
   使用了一个二维数组 `dp` 来存储子问题的结果，空间复杂度为 `O(n^2)`。

3. **问题特点**：  
   - 只关心最小计算代价，不实际进行矩阵的乘法。
   - 动态规划通过记忆化避免了重复计算，提高效率。

4. **适用场景**：  
   - 优化矩阵计算顺序。
   - 多阶段决策问题的优化。
